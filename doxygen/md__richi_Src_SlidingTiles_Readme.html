<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Sliding Tiles: Sliding Tiles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sliding Tiles
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Sliding Tiles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Implementing classes must define the render method */ virtual void render() = 0;</p>
<p><a href="https://travis-ci.org/richardeigenmann/SlidingTiles"></a> <a href="https://codecov.io/gh/richardeigenmann/SlidingTiles"></a> <a href="https://www.codacy.com/app/richardeigenmann/SlidingTiles?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=richardeigenmann/SlidingTiles&amp;amp;utm_campaign=Badge_Grade"></a></p>
<h2>Screenshot</h2>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/Screenshot.png"  alt="Screenshot"/>
</div>
<h2>Description:</h2>
<p>This program creates a window and places tiles in a grid. The tiles can be slid around by dragging the mouse. When the start and end tile match up in a path you win.</p>
<h3>Patterns</h3>
<ul>
<li>Singleton</li>
<li>Observer</li>
<li>Pub-Sub Messaging</li>
<li>Actor</li>
<li>RAII</li>
<li>shared_ptr</li>
<li>Unit Testing</li>
</ul>
<h3>Algorithms</h3>
<ul>
<li>Breadth-First-Search</li>
</ul>
<h3>Frameworks</h3>
<ul>
<li>SFML</li>
<li>ZeroMQ</li>
<li>Google Test</li>
<li>Doxygen</li>
<li>TravisCI</li>
</ul>
<h3>Features</h3>
<ul>
<li>cross platform (sort of)</li>
<li>Graphics &amp; Sound</li>
<li>Animation</li>
<li>C++ 11</li>
<li>Code Coverage</li>
</ul>
<p>## Build and run </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir -p build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake .. </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;# or cmake -DCMAKE_CXX_COMPILER=/usr/bin/clang++ -DCMAKE_CC_COMPILER=/usr/bin/clang .. </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;# or cmake -DCMAKE_CXX_COMPILER=/usr/bin/g++-6 -DCMAKE_CC_COMPILER=/usr/bin/gcc .. </div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;make</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;./sliding-tiles</div></div><!-- fragment --><h2>Build and run on Visual Studio 2017</h2>
<p>Currently broken because of broken UTF-8 support</p>
<p>This is a CMake project. That means that we let CMake create the solution files in the build directory from the CMakeLists.txt file</p>
<p>You need to install</p><ul>
<li><a href="https://cmake.org/download">CMake</a></li>
<li><a href="https://www.python.org/downloads/release">Python 2.x, not 3.x</a></li>
<li><a href="https://www.sfml-dev.org/download.php">SFML</a></li>
<li><a href="https://www.visualstudio.com/downloads">Visual Studio 2017</a></li>
</ul>
<p>On windows there is no standard place that SFML goes. So you need to tell CMake in the CMakeLists.txt file where it is. Edit this file and adjust the SFML_ROOT delcaration on line 6.</p>
<p>Then open the CMake GUI. It wants to know "Where is the source code:". Give it the sliding-tiles root directory. It also wants to know the build directory. Create a build subdirectory and point the gui at that.</p>
<p>Click the Configure button. If you do this the first time it will ask you for the generator. Pick the Visual Sutdio 15 2017 Win64 generator. Be sure to pick a 64 bit generator if you downloaded the 64 bit SFML library! You could end up with an unhelpful linker error saying it doesn't like x86 in a x64 project.</p>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/cmake.png"  alt="CMakeScreenshot"/>
</div>
<p>Then click Generate to create the sliding-tiles.sln solution file along with lots of other stuff in the sliding-tiles/build directory. Open this with Visual Studio 2017 by clicking "Open Project".</p>
<p>To build the software click Build &gt; Build Solution from the menu. (Be sure not to have the game open or the build will fail to overwrite the exe file "LINK1168: Cannot open ... for writing".)</p>
<p>You should now have a sliding-tiles.exe file in the sliding-tiles/build/Debug directory. You can run it from that directory or start it with the debugger (green triangle or F5).</p>
<p>To run the unit tests. Right click in the Solution Explorer on "unit-tests" and pick "Set as StartUp project". Now you can run them without the debugger by pressing Ctrl-F5 or perhaps with the debugger by pressing F5 (but the terminal window closes on you then).</p>
<p>## Doxygen Documentation </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir -p build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;doxygen ../Doxyfile</div></div><!-- fragment --><p>Then open the file in html/index.html in the browser</p>
<p>## Testing </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir -p build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake ..</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;make</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;make test</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# or</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;./unit-tests</div></div><!-- fragment --><h2>Code Coverage</h2>
<p>To generate code coverage reports from the unit tests run the below steps. The CodeCoverage.cmake file used gcov from the gcc installation and lcov which has to be installed separately to generate an html coverage report.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir -p build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake ..</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;make</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;make sliding-tiles_coverage</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# open the file coverage/index.html with a browser</div></div><!-- fragment --> <h2>Notable Points:</h2>
<h3>Segfault on textures</h3>
<p>What's the difference between</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sf::Texture &amp; getTexture(const TileType &amp; tileType) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return texturesMap[tileType];</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div></div><!-- fragment --><p>And this? </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sf::Texture getTexture(const TileType &amp; tileType) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return texturesMap[tileType];</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div></div><!-- fragment --><p>And what kind of difference could it possibly make to this code? </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void TileView::render() {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    sf::Sprite sprite;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    sprite.setTexture(TexturesSingleton::getInstance().getTexture(tileType));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    sprite.setPosition(renderPosition.x, renderPosition.y);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    RenderingSingleton::getInstance().getRenderWindow()-&gt;draw(sprite);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p>Turns out a huge difference: The difference is that easy-to-overlook little ampersand in the return value declaration of the getTexture method.</p>
<p>Without the ampersand the method returns a copy of the texture from the texturesMap (which exists only once in the singleton). Whilst perhaps not optimally efficient why should this be a problem? After all, the texture exists till the closing brace in the render method. A few hundred segfaults later my suspicion is that the draw method goes off into some asynchronous heaven and by the time it gets round to picking up the texture the closing brace has come along and wiped the texture off the stack and we get a segfault.</p>
<p>By adding the ampersand the getTexture method returns a reference to the texture in the map. This is also on the stack but the texturesMap is a long living object in the singleton so it does not go away and any delayed draw can happily access it.</p>
<h3>Searching for a solution - A breadth first search!</h3>
<p>For a human it is easy to see how to solve this puzzle:</p>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/solver1.png"  alt="Solver1"/>
</div>
 <div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/solver2.png"  alt="Solver2"/>
</div>
 <div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/solver3.png"  alt="Solver3"/>
</div>
<p>To solve programatically we can take a brute-force approach: Start with the puzzle and figure out all possible moves that can be made by the tiles. In this puzzle there is only one tile that can move (start and end tiles are fixed). It can move in 4 directions.</p>
<p>If the tile moves to the right on the next move it can still move 3 ways. Note that moving back is not desirable so we will only consider 3 potential moves.</p>
<p>If the tile moves to the right once more then it has no more future moves. In this situation that is OK because the puzzle has been solved.</p>
<p>This making-a-move and then having multiple next moves can be expressed as a tree:</p>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/Level1.png"  alt="Level1"/>
</div>
<p>We can visit each node and see if there are new moves (excluding the go back move):</p>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/Level2.png"  alt="Level2"/>
</div>
<p>As we go n-deep the number of nodes increases. I'm sure there is some optimisation that could be applied to prevent tiles moving round in circles. But we are on the brute-force approach here...</p>
<div class="image">
<img src="http://opentechschool-zurich.github.io/cpp-co-learning/topics/games/monkey-keg/Richard/sliding-tiles/doc/Level4.png"  alt="Level4"/>
</div>
<p>Which path is the fastest one that leads to a solved puzzle? Enter the breadth-first search:</p>
<div class="image">
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif"  alt="Breadth-First-Search"/>
</div>
<p>(From Wikipedia: <a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a> )</p>
<p>Here is "my" code to find the shortest solution path: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;bool PuzzleSolver::hasASolution(const MoveNode &amp; node) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    // inspired by https://gist.github.com/douglas-vaz/5072998</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    std::queue&lt;MoveNode&gt; Q;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    Q.push(node);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    while (!Q.empty()) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        MoveNode t = Q.front();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        Q.pop();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        gameBoard.loadGame(t.endingBoard);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        if (gameBoard.isSolved().size() &gt; 0) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;            return true;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        };</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        for (int i = 0; i &lt; t.possibleMoves.size(); ++i) {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;            Q.push(t.possibleMoves[i]);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    }</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    return false;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div></div><!-- fragment --><p>I was impressed with the queue approach which avoids a recursive call. The method places the root node on the queue and then reads nodes off the front of the queue. If the endboard of the move isn't a solved puzzle the method looks for the child moves and adds them at the end of the queue. This way first all the level 1 nodes are visited before the level 2 nodes are checked and so on.</p>
<h2>Rendering with a Rendering Singleton where Renderables register themselves</h2>
<p>The SFML documentation suggests that you use this code to draw a window. Note how the loop in the main method clears the canvas then draws the various objects and then displays the window. This means that the main loop needs to know about everything that is going on in the game and needs to keep track of it's state so it can decide what to draw. For instance you would not want to draw the victory roll banner while the game is still playing.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;SFML/Audio.hpp&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;SFML/Graphics.hpp&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int main()</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // Create the main window</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    sf::RenderWindow window(sf::VideoMode(800, 600), &quot;SFML window&quot;);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // Load a sprite to display</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    sf::Texture texture;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    if (!texture.loadFromFile(&quot;cute_image.jpg&quot;))</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        return EXIT_FAILURE;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    sf::Sprite sprite(texture);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    // Create a graphical text to display</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    sf::Font font;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    if (!font.loadFromFile(&quot;arial.ttf&quot;))</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        return EXIT_FAILURE;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    sf::Text text(&quot;Hello SFML&quot;, font, 50);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    // Load a music to play</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    sf::Music music;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    if (!music.openFromFile(&quot;nice_music.ogg&quot;))</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        return EXIT_FAILURE;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    // Play the music</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    music.play();</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    // Start the game loop</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    while (window.isOpen())</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        // Process events</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        sf::Event event;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        while (window.pollEvent(event))</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            // Close window: exit</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;            if (event.type == sf::Event::Closed)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                window.close();</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        }</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        // Clear screen</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        window.clear();</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        // Draw the sprite</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        window.draw(sprite);</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        // Draw the string</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        window.draw(text);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        // Update the window</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        window.display();</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    return EXIT_SUCCESS;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;}</div></div><!-- fragment --><p>I didn't like my code after a few hundred lines. Can't we do better?</p>
<p>I chose to create an object that knows which objects can be rendered and then calls them in the correct Z-order. Thus when the renderable objects are created they register themselves with the renderer during object construction and de-register themselves when they get destructed.</p>
<p>So we need a class with a pure virtual function that the renderable objects can inherit and add their draw function to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;class Renderable {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;public:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    /**</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     *    /**</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     * an enum to hold the priority of the renderable. It can be</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;     * Background, Normal and OnTop. This is the order in which the</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;     * renderables will be drawn.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;     */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    enum RenderPriority {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        Background,</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        Normal,</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        OnTop</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    };</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    /**</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      * Inheriting classes can override this function to change the priority.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;      * @return The RenderPriority enum value</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      */</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    virtual RenderPriority getRenderPriority() {</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        return RenderPriority::Normal;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;};</div></div><!-- fragment --><p>Next we need the Rendering Singleton. We use the Observer pattern and kill off the default constructors so that you can only call the static getInstance() method which will create the exactly one instance and return it.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;class RenderingSingleton {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;public:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    /**</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;     * Deleted to enforce singleton pattern</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;     */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    RenderingSingleton(RenderingSingleton const&amp;) = delete;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    /**</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;     * Deleted to enforce singleton pattern</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;     */</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    void operator=(RenderingSingleton const&amp;) = delete;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    /**</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;     * returns the single instance of the RenderingSingleton</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;     */</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    static RenderingSingleton&amp; getInstance() {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        static RenderingSingleton instance; // Guaranteed to be destroyed.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        // Instantiated on first use.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        return instance;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    }</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;private:</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    /**</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;     * Private constructor for singleton</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;     */</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    RenderingSingleton();</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;};</div></div><!-- fragment --><p>Next our RenderingSingleton needs to allow Renderables to register and deregister themselves. Following an example of the Observer pattern we use a std::map to hold the references to the Renderables.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/**</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; * The map of Renderables</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;std::map&lt;Renderable * const, Renderable * const&gt; renderables;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/**</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; * Add a Renderable to the list of object to render</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; * @param renderable The Renderable to add</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;void add(Renderable&amp; renderable) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    renderables.insert(std::pair&lt;Renderable * const, Renderable * const&gt;(&amp;renderable, &amp;renderable));</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;/**</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; * Removes a renderable from the list of objects to render</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; * @param renderable The Renderable to remove</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; */</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;void remove(Renderable&amp; renderable) {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    renderables.erase(&amp;renderable);</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;}</div></div><!-- fragment --><p>And finally our RenderingSingleton needs to call each registered Renderables to ask it to render itself.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/**</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; * Tell all renderables to render</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;void renderAll() {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    for (auto&amp; pair : renderables) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        if (pair.second-&gt;getRenderPriority() == Renderable::RenderPriority::Background) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;            pair.second-&gt;render();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    for (auto&amp; pair : renderables) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        if (pair.second-&gt;getRenderPriority() == Renderable::RenderPriority::Normal) {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;            pair.second-&gt;render();</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    for (auto&amp; pair : renderables) {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        if (pair.second-&gt;getRenderPriority() == Renderable::RenderPriority::OnTop) {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;            pair.second-&gt;render();</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        }</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    }</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    getRenderWindow()-&gt;display();</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div></div><!-- fragment --><p>Now classes like Button can inherit from Renderable and can register themselves with the Rendering Singleton upon creation. The render() method is called by the RenderingSingleton at the right time when the button needs to be drawn,</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;class Button : public Renderable ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Button::Button() {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    RenderingSingleton::getInstance().add(*this);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;~Button() {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    RenderingSingleton::getInstance().remove(*this);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;void render() {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    RenderingSingleton::getInstance().getRenderWindow()-&gt;draw(sprite);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --><p>Check out the whole implementation of the RenderingSingleton in the <a href="renderingSingleton.h">renderingSingleton.h</a> and <a href="renderingSingleton.cpp">renderingSingleton.cpp</a> files.</p>
<p>The same concept is used for the update cycle. Check out the whole implementation of the UpdatingSingleton in the <a href="updatingSingleton.h">updatingSingleton.h</a> and <a href="updatingSingleton.cpp">updatingSingleton.cpp</a> and <a href="updatable.h">updatable.h</a> files.</p>
<h2>Messaging</h2>
<p>The early versions of the game were built on the premise that the Game class directed the flow of events. The Game class would order a puzzle to be loaded and would tell the WinnerBlingBling class to celebrate the win. This approach is fine for simple applications but there are drawbacks. If something changes you have to go back to the Game class and fix it there. A lot of code accumulates there and you don't end up with a good "separation of concerns".</p>
<p>A more modern design uses loose coupling where the various objects don't know or care about the bigger picture. They just listen out for things they are concerned with and react accordingly. I.e. the WinnerBlingBling class only needs to know that the game was won and can start the merriment.</p>
<p>ZeroMQ is a fast versatile messaging library that lets us implement the pub-sub publisher - subscriber pattern. This allows a publisher to broadcast messages that the subscribers receive and can act upon.</p>
<p>I have chosen to use JSON as a format for my messages as the game already links to Niels Lohmann's library and JSON is a nice versatile format. Obviously the serialisation and deserialisation comes at a cost so this approach might not work in all cases.</p>
<p>The game probably has multiple places that need to send messages so I created a ZmqSingleton ( <a href="zmqSingleton.h">zmqSingleton.h</a> and <a href="zmqSingleton.cpp">zmqSingleton.cpp</a> ) where any class can call the publish(const std::string &amp; message) function.</p>
<p>ZeroMQ can transport the messages over various kinds of connection. Most common certainly is the use of TCP sockets. But it also support In-Process connections. For this to work, though, the <a class="el" href="classzmq_1_1context__t.html">zmq::context_t</a> object must be shared. I chose to use the ZmqSingleton as the carrier for the context object which is distributed to any caller by means of a shared_ptr.</p>
<p>In the receiving classes we need to connect to the socket and check if a message was received. The best place to review this is the DebugMessageListener class: <a href="debugMessageListener.h">debugMessageListener.h</a> and <a href="debugMessageListener.cpp">debugMessageListener.cpp</a></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// The constructor for a listener needs to bind to the ZeroMQ context and open </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// a ZMQ_SUB socket which it can connect to as a tcp port, in process etc.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// It also extends the Updatable and registers there so that it gets update() callbacks.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;DebugMessageListener::DebugMessageListener() {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    UpdatingSingleton::getInstance().add(*this);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    std::cout &lt;&lt; &quot;DebugMessageListener connecting to ZeroMQ socket: &quot;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;            &lt;&lt; ZmqSingleton::RECEIVER_SOCKET &lt;&lt; std::endl;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    contextPtr = ZmqSingleton::getInstance().getContext();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    socket = std::make_unique&lt;zmq::socket_t&gt;(*contextPtr, ZMQ_SUB);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    socket-&gt;connect(ZmqSingleton::RECEIVER_SOCKET);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    socket-&gt;setsockopt(ZMQ_SUBSCRIBE, 0, 0);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;void DebugMessageListener::update(const float dt) {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    zmq::message_t reply;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    if (socket-&gt;recv(&amp;reply, ZMQ_NOBLOCK)) {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        std::string message = std::string(static_cast&lt;char*&gt; (reply.data()), reply.size());</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        std::cout &lt;&lt; &quot;DebugMessageListener received: &quot; &lt;&lt; message &lt;&lt; std::endl;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div></div><!-- fragment --><p>The ZmqSingleton creates the context and socket as a private member variable:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;std::shared_ptr&lt;zmq::context_t&gt; contextPtr = std::make_shared&lt;zmq::context_t&gt;(1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;zmq::socket_t socket{*contextPtr, ZMQ_PUB};</div></div><!-- fragment --><p>It makes the context available:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;std::shared_ptr&lt;zmq::context_t&gt; &amp; getContext() {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return contextPtr;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --><p>And it facilitates publishing a message:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void ZmqSingleton::publish(const json &amp; jsonMessage) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    std::string message = jsonMessage.dump();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    zmq::message_t zmqMessage(message.size());</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    memcpy(zmqMessage.data(), message.data(), message.size());</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    socket.send(zmqMessage);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p>Which can be used when the game is won:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;json jsonMessage{};</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;jsonMessage[&quot;state&quot;] = ZmqSingleton::GAME_WON;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;jsonMessage[&quot;victoryRollTime&quot;] = VICTORY_ROLL_TIME;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;jsonMessage[&quot;moves&quot;] = moves;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;jsonMessage[&quot;par&quot;] = par;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;for (const auto &amp; solutionStep : solutionPath) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    jsonMessage[&quot;solutionTiles&quot;].push_back({solutionStep.x, solutionStep.y});</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;ZmqSingleton::getInstance().publish(jsonMessage);</div></div><!-- fragment --><h2>Copyright information</h2>
<p>This project is copyrighted by Richard Eigenmann, Zürich, 2016,2017. I have not yet decided on a license. Please contact me with any questions.</p>
<p>The source includes a copy of JSON for Modern C++ from Niels Lohmann <a href="https://github.com/nlohmann/json">GitHub</a> This is MIT licenced.</p>
<p>Trophy Clipart from <a href="http://www.clipartbest.com/clipart-aieonzEzT">http://www.clipartbest.com/clipart-aieonzEzT</a></p>
<p>The buttons were created by <a href="https://dabuttonfactory.com/">https://dabuttonfactory.com/</a></p>
<p>The Raleway font is a Google Font with Open Font License: <a href="https://fonts.google.com/specimen/Raleway">https://fonts.google.com/specimen/Raleway</a></p>
<p>The tiles were drawn by Richard Eigenmann using Blender. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
